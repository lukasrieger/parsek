package error

import error.ParseError.FancyError
import error.ParseError.TrivialError
import util.Ordering
import util.compare


sealed interface ParseError<out E> {

    /**
     * The error offset
     */
    val offset: Int

    /**
     * Trivial errors, generated by the parsek.
     */
    data class TrivialError<out T>(
        /**
         * The error offset
         */
        override val offset: Int,
        /**
         * The unexpected token that was encountered (if any)
         */
        val unexpected: ErrorItem<T>?,
        /**
         * List of expected tokens instead of [unexpected]
         */
        val expected: Set<ErrorItem<T>>
    ) : ParseError<Nothing> {
        override fun toString() = pretty()
    }


    data class FancyError<out E>(
        override val offset: Int,
        val errors: Set<ErrorFancy<E>>
    ) : ParseError<E> {
        override fun toString() = pretty()
    }


}

internal operator fun <E> ParseError<E>.plus(other: ParseError<E>): ParseError<E> = merge(other)


infix fun <E> ParseError<E>.merge(other: ParseError<E>): ParseError<E> {
    infix fun ErrorItem<*>?.combine(b: ErrorItem<*>?): ErrorItem<*>? = when {
        this == null && b == null -> null
        this != null && b == null -> this
        this == null && b != null -> b
        this != null && b != null -> maxOf(this, b)
        else -> error("unreachable")
    }

    return when (offset compare other.offset) {
        is Ordering.EQ -> when {
            this is TrivialError<*> && other is TrivialError<*> -> {
                TrivialError(
                    this.offset,
                    this.unexpected combine other.unexpected,
                    this.expected + other.expected
                )
            }

            this is FancyError && other is TrivialError<*> -> this
            this is TrivialError<*> && other is FancyError -> other
            this is FancyError && other is FancyError ->
                FancyError(this.offset, this.errors + other.errors)

            else -> error("unreachable.")
        }

        is Ordering.GT -> this
        is Ordering.LT -> other
    }
}


internal fun ParseError<*>.pretty(): String =
    "offset=" + offset + ":\n" + textPretty()

internal fun ParseError<*>.textPretty(): String = when (this) {
    is FancyError -> {
        if (errors.isEmpty()) {
            "unknown fancy parse error\n"
        } else {
            errors.toList().sortedDescending().joinToString("\n") { it.pretty() }
        }
    }

    is TrivialError<*> -> {
        if (unexpected == null && expected.isEmpty()) {
            "unknown parse error\n"
        } else {
            errorItemsPretty(
                prefix = "unexpected ",
                messages = setOfNotNull(unexpected).map { it.pretty() }.reversed().toSet()
            ) + errorItemsPretty(
                prefix = "expecting ",
                messages = expected.map { it.pretty() }.reversed().toSet()
            )
        }
    }
}


private fun errorItemsPretty(prefix: String, messages: Set<String>): String = when {
    messages.isEmpty() -> ""
    else -> prefix + messages.toList().orList() + "\n"
}

private fun List<String>.orList(): String = joinToString(" or ")
