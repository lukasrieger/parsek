import arrow.core.NonEmptyList
import util.Ordering
import util.compare
import kotlin.math.max

private val ErrorItem<*>.errorItemLength: Int
    get() = when (this) {
        is ErrorItem.Tokens -> this.tokens.map { it.toString().length }.sum()
        else -> 1
    }


private val ErrorFancy<*>.errorFancyLength: Int
    get() = when (this) {
        is ErrorFancy.ErrorCustom -> error.toString().length
        else -> 1
    }


sealed interface ParseError<out S, out E> {

    val offset: Int

    /**
     * Trivial errors, generated by the parsek.
     */
    data class TrivialError<S, T>(
        /**
         * The error offset
         */
        override val offset: Int,
        /**
         * The unexpected token that was encountered (if any)
         */
        val unexpected: ErrorItem<T>?,
        /**
         * List of expected tokens instead of [unexpected]
         */
        val expected: Set<ErrorItem<T>>
    ) : ParseError<S, Nothing>


    data class FancyError<E>(
        override val offset: Int,
        val errors: Set<ErrorFancy<E>>
    ) : ParseError<Nothing, E>

}


infix fun <S, E> ParseError<S, E>.merge(other: ParseError<S, E>): ParseError<S, E> {
    fun n(a: ErrorItem<*>?, b: ErrorItem<*>?): ErrorItem<*>? = when {
        a == null && b == null -> null
        a != null && b == null -> a
        a == null && b != null -> b
        a != null && b != null -> maxOf(a, b)
        else -> error("unreachable")
    }

    return when (offset compare other.offset) {
        is Ordering.EQ -> when {
            this is ParseError.TrivialError<*, *> && other is ParseError.TrivialError<*, *> -> {
                ParseError.TrivialError(
                    this.offset,
                    n(this.unexpected, other.unexpected),
                    this.expected + other.expected
                )
            }

            this is ParseError.FancyError && other is ParseError.TrivialError<*, *> -> this
            this is ParseError.TrivialError<*, *> && other is ParseError.FancyError -> other
            this is ParseError.FancyError && other is ParseError.FancyError ->
                ParseError.FancyError(this.offset, this.errors + other.errors)

            else -> error("unreachable.")
        }

        is Ordering.GT -> this
        is Ordering.LT -> other
    }
}


internal operator fun <E> ParseError<*, E>.plus(err: ParseError<*, E>): ParseError<*, E> =
    merge(err)


sealed interface ErrorItem<out T> : Comparable<ErrorItem<*>> {

    override fun compareTo(other: ErrorItem<*>): Int = 0


    data class Tokens<T>(
        val tokens: NonEmptyList<T>
    ) : ErrorItem<T>

    data class Label(
        val label: String
    ) : ErrorItem<Nothing>

    data object EndOfInput : ErrorItem<Nothing>
}


sealed interface ErrorFancy<out E> : Comparable<ErrorFancy<*>> {

    override fun compareTo(other: ErrorFancy<*>): Int = 0 // TODO

    data class ErrorFail(val error: String) : ErrorFancy<Nothing>

    data class ErrorIndentation(val error: Ordering<Pos, Pos>) : ErrorFancy<Nothing>

    data class ErrorCustom<E>(val error: E) : ErrorFancy<E>

}

data class ParseErrorBundle<S : Stream<*, *>, E>(
    val bundleErrors: NonEmptyList<ParseError<S, E>>,
    val bundlePosState: PosState<S>
) {

    override fun toString(): String = pretty()
}


fun ParseErrorBundle<*, *>.pretty(): String {
    fun f(posState: PosState<out Stream<*, *>>, error: ParseError<*, *>): String {
        val (msline, pst) =
            posState.pStateInput.reachOffset(error.offset, posState)

        val epos = pst.pStateSourcePos

        val offendingLine: String = when (msline) {
            null -> ""
            else -> {
                val slineLen = msline.length
                val rpShift = epos.sourceColumn.pos - 1
                val lineNumber = epos.sourceLine.pos.toString()
                val padding = " ".repeat(lineNumber.length + 1)

                val elen = when (error) {
                    is ParseError.FancyError -> error.errors.fold(1) { a, b ->
                        max(a, b.errorFancyLength)
                    }

                    is ParseError.TrivialError<*, *> -> if (error.unexpected == null) {
                        1
                    } else {
                        error.unexpected.errorItemLength
                    }
                }
                val pointerLen = if (rpShift + elen > slineLen) {
                    slineLen - rpShift + 1
                } else {
                    elen
                }
                val rpadding = if (pointerLen > 0) " ".repeat(rpShift) else ""
                val pointer = "^".repeat(pointerLen)

                buildString {
                    append(padding)
                    append("|\n")
                    append(lineNumber)
                    append(" | ")
                    append(msline)
                    append("\n")
                    append(padding)
                    append("| ")
                    append(rpadding)
                    append(pointer)
                    append("\n")
                }
            }
        }

        return buildString {
            append("\n")
            append(epos.pretty())
            append(":\n")
            append(offendingLine)
            append(error.textPretty())
        }
    }

    return this.bundleErrors.fold("") { acc, b ->
        acc + f(bundlePosState, b)
    }
}


private fun ParseError<*, *>.pretty(): String =
    "offset=" + offset + ":\n" + textPretty()

private fun ParseError<*, *>.textPretty(): String = when (this) {
    is ParseError.FancyError -> {
        if (errors.isEmpty()) {
            "unknown fancy parse error\n"
        } else {
            errors.toList().sorted().joinToString("\n") { it.pretty() }
        }
    }

    is ParseError.TrivialError<*, *> -> {
        if (unexpected == null && expected.isEmpty()) {
            "unknown parse error\n"
        } else {
            errorItemsPretty(
                prefix = "unexpected ",
                messages = setOfNotNull(unexpected).map { it.pretty() }.toSet()
            ) + errorItemsPretty(
                prefix = "expecting ",
                messages = expected.map { it.pretty() }.toSet()
            )
        }
    }
}

private fun ErrorItem<*>.pretty(): String = when (this) {
    is ErrorItem.EndOfInput -> "end of input"
    is ErrorItem.Label -> label
    is ErrorItem.Tokens -> tokens.joinToString("") { it.prettyChar() ?: it.toString() }
}

private fun <E> ErrorFancy<E>.pretty(): String = when (val err = this) {
    is ErrorFancy.ErrorCustom -> err.error.toString()
    is ErrorFancy.ErrorFail -> err.error
    is ErrorFancy.ErrorIndentation -> buildString {
        val (ref, actual) = err.error
        val p = when (err.error) {
            is Ordering.EQ -> "equal to "
            is Ordering.GT -> "greater than "
            is Ordering.LT -> "less than "
        }

        append("incorrect indentation (got")
        append(actual.pos)
        append(", should be")
        append(p)
        append(ref.pos)
        append(")")
    }
}

private fun errorItemsPretty(prefix: String, messages: Set<String>): String = when {
    messages.isEmpty() -> ""
    else -> prefix + messages.toList().orList() + "\n"
}

private fun List<String>.orList(): String = joinToString(" or ")


fun Any?.prettyChar() = when (this) {
    ' ' -> "space"
    '\t' -> "tab"
    '\n' -> "newline"
    '\r' -> "carriage return"
    else -> null
}?.let { "<$it>" }
