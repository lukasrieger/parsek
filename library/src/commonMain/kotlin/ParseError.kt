import arrow.core.NonEmptyList
import util.Ordering

sealed interface ParseError<out E> {

    /**
     * Trivial errors, generated by the parsek.
     */
    data class TrivialError(
        /**
         * The error offset
         */
        val offset: Int,
        /**
         * The unexpected token that was encountered (if any)
         */
        val unexpected: ErrorItem<Char>?,
        /**
         * List of expected tokens instead of [unexpected]
         */
        val expected: Set<ErrorItem<Char>>
    ) : ParseError<Nothing>


    data class FancyError<E>(
        val offset: Int,
        val errors: Set<ErrorFancy<E>>
    ) : ParseError<E>

}


internal operator fun <E> ParseError<E>.plus(err: ParseError<E>): ParseError<E> = TODO("Not yet implemented")


sealed interface ErrorItem<out T> {

    data class Tokens<T>(
        val tokens: NonEmptyList<T>
    ) : ErrorItem<T>

    data class Label(
        val label: String
    ) : ErrorItem<Nothing>

    data object EndOfInput : ErrorItem<Nothing>
}


sealed interface ErrorFancy<out E> {

    data class ErrorFail(val error: String) : ErrorFancy<Nothing>

    data class ErrorIndentation(val error: Ordering<Pos, Pos>) : ErrorFancy<Nothing>

    data class ErrorCustom<E>(val error: E) : ErrorFancy<E>

}